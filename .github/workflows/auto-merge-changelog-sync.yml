name: Auto-Merge Changelog Sync

on:
  schedule:
    - cron: "0 10 * * *" # 6am US Eastern Time (ET) = 10:00 UTC
  workflow_dispatch:
  repository_dispatch:
    types: [release-published]

jobs:
  sync-and-automerge:
    runs-on: ubuntu-latest
    permissions:
      contents: write
      pull-requests: write
      checks: read
      actions: read

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          fetch-depth: 0

      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: "22"

      - name: Fetch latest releases from all repositories
        id: fetch_latest_releases
        run: |
          echo "Fetching latest releases from all Bluefin repositories..."

          # Initialize status tracking
          REPOSITORIES_ACCESSED=""
          REPOSITORIES_FAILED=""

          # Fetch all releases from ublue-os/bluefin to find latest stable and GTS
          echo "Fetching all releases from ublue-os/bluefin..."
          BLUEFIN_RELEASES=$(curl -s -H "Accept: application/vnd.github.v3+json" \
            -H "Authorization: Bearer ${{ secrets.GITHUB_TOKEN }}" \
            "https://api.github.com/repos/ublue-os/bluefin/releases")

          # Check if request was successful - check for both HTTP errors and API error messages
          if [[ -z "$BLUEFIN_RELEASES" ]] || echo "$BLUEFIN_RELEASES" | jq -e '.message // .errors' > /dev/null 2>&1 || ! echo "$BLUEFIN_RELEASES" | jq empty > /dev/null 2>&1; then
            echo "Warning: Failed to fetch bluefin releases"
            echo "API Response: $BLUEFIN_RELEASES"
            REPOSITORIES_FAILED="$REPOSITORIES_FAILED ublue-os/bluefin"
          else
            REPOSITORIES_ACCESSED="$REPOSITORIES_ACCESSED ublue-os/bluefin"
            
            # Find latest stable release (tag contains 'stable')
            if BLUEFIN_STABLE_RELEASE=$(echo "$BLUEFIN_RELEASES" | jq -r '[.[] | select(.tag_name | test("stable")) | select(.prerelease == false)] | .[0]' 2>/dev/null) && [[ "$BLUEFIN_STABLE_RELEASE" != "null" && -n "$BLUEFIN_STABLE_RELEASE" ]]; then
              if BLUEFIN_STABLE_TAG=$(echo "$BLUEFIN_STABLE_RELEASE" | jq -r '.tag_name' 2>/dev/null) && \
                 BLUEFIN_STABLE_URL=$(echo "$BLUEFIN_STABLE_RELEASE" | jq -r '.html_url' 2>/dev/null) && \
                 BLUEFIN_STABLE_DATE=$(echo "$BLUEFIN_STABLE_RELEASE" | jq -r '.published_at' 2>/dev/null) && \
                 [[ "$BLUEFIN_STABLE_TAG" != "null" && "$BLUEFIN_STABLE_URL" != "null" && "$BLUEFIN_STABLE_DATE" != "null" ]]; then

                echo "Latest stable release found: $BLUEFIN_STABLE_TAG"
                echo "Stable release URL: $BLUEFIN_STABLE_URL"
                
                # Save stable release data
                echo "bluefin_stable_tag=$BLUEFIN_STABLE_TAG" >> $GITHUB_OUTPUT
                echo "bluefin_stable_url=$BLUEFIN_STABLE_URL" >> $GITHUB_OUTPUT
                echo "bluefin_stable_date=$BLUEFIN_STABLE_DATE" >> $GITHUB_OUTPUT
                echo "bluefin_stable_available=true" >> $GITHUB_OUTPUT
              else
                echo "Error parsing stable release data"
                echo "bluefin_stable_available=false" >> $GITHUB_OUTPUT
              fi
            else
              echo "No stable releases found"
              echo "bluefin_stable_available=false" >> $GITHUB_OUTPUT
            fi
            
            # Find latest GTS release (tag contains 'gts')
            if BLUEFIN_GTS_RELEASE=$(echo "$BLUEFIN_RELEASES" | jq -r '[.[] | select(.tag_name | test("gts"))] | .[0]' 2>/dev/null) && [[ "$BLUEFIN_GTS_RELEASE" != "null" && -n "$BLUEFIN_GTS_RELEASE" ]]; then
              if BLUEFIN_GTS_TAG=$(echo "$BLUEFIN_GTS_RELEASE" | jq -r '.tag_name' 2>/dev/null) && \
                 BLUEFIN_GTS_URL=$(echo "$BLUEFIN_GTS_RELEASE" | jq -r '.html_url' 2>/dev/null) && \
                 BLUEFIN_GTS_DATE=$(echo "$BLUEFIN_GTS_RELEASE" | jq -r '.published_at' 2>/dev/null) && \
                 [[ "$BLUEFIN_GTS_TAG" != "null" && "$BLUEFIN_GTS_URL" != "null" && "$BLUEFIN_GTS_DATE" != "null" ]]; then

                echo "Latest GTS release found: $BLUEFIN_GTS_TAG"
                echo "GTS release URL: $BLUEFIN_GTS_URL"
                
                # Save GTS release data
                echo "bluefin_gts_tag=$BLUEFIN_GTS_TAG" >> $GITHUB_OUTPUT
                echo "bluefin_gts_url=$BLUEFIN_GTS_URL" >> $GITHUB_OUTPUT
                echo "bluefin_gts_date=$BLUEFIN_GTS_DATE" >> $GITHUB_OUTPUT
                echo "bluefin_gts_available=true" >> $GITHUB_OUTPUT
              else
                echo "Error parsing GTS release data"
                echo "bluefin_gts_available=false" >> $GITHUB_OUTPUT
              fi
            else
              echo "No GTS releases found"
              echo "bluefin_gts_available=false" >> $GITHUB_OUTPUT
            fi
          fi

          # Try to fetch the latest release from ublue-os/bluefin-lts
          echo "Fetching latest release from ublue-os/bluefin-lts..."
          BLUEFIN_LTS_RELEASE=$(curl -s -H "Accept: application/vnd.github.v3+json" \
            -H "Authorization: Bearer ${{ secrets.GITHUB_TOKEN }}" \
            "https://api.github.com/repos/ublue-os/bluefin-lts/releases/latest")

          # Check if LTS request was successful - check for both HTTP errors and API error messages
          if [[ -z "$BLUEFIN_LTS_RELEASE" ]] || echo "$BLUEFIN_LTS_RELEASE" | jq -e '.message // .errors' > /dev/null 2>&1 || ! echo "$BLUEFIN_LTS_RELEASE" | jq empty > /dev/null 2>&1; then
            echo "Warning: Failed to fetch latest bluefin-lts release"
            echo "API Response: $BLUEFIN_LTS_RELEASE"
            REPOSITORIES_FAILED="$REPOSITORIES_FAILED ublue-os/bluefin-lts"
            echo "bluefin_lts_available=false" >> $GITHUB_OUTPUT
          else
            # Extract bluefin-lts release information with error handling
            if BLUEFIN_LTS_TAG=$(echo "$BLUEFIN_LTS_RELEASE" | jq -r '.tag_name' 2>/dev/null) && \
               BLUEFIN_LTS_URL=$(echo "$BLUEFIN_LTS_RELEASE" | jq -r '.html_url' 2>/dev/null) && \
               BLUEFIN_LTS_DATE=$(echo "$BLUEFIN_LTS_RELEASE" | jq -r '.published_at' 2>/dev/null) && \
               [[ "$BLUEFIN_LTS_TAG" != "null" && "$BLUEFIN_LTS_URL" != "null" && "$BLUEFIN_LTS_DATE" != "null" ]]; then

              echo "Latest bluefin-lts release found: $BLUEFIN_LTS_TAG"
              REPOSITORIES_ACCESSED="$REPOSITORIES_ACCESSED ublue-os/bluefin-lts"
              
              # Save LTS release data
              echo "bluefin_lts_tag=$BLUEFIN_LTS_TAG" >> $GITHUB_OUTPUT
              echo "bluefin_lts_url=$BLUEFIN_LTS_URL" >> $GITHUB_OUTPUT
              echo "bluefin_lts_date=$BLUEFIN_LTS_DATE" >> $GITHUB_OUTPUT
              echo "bluefin_lts_available=true" >> $GITHUB_OUTPUT
            else
              echo "Error parsing LTS release data"
              echo "bluefin_lts_available=false" >> $GITHUB_OUTPUT
            fi
          fi

          # Output summary
          echo "repositories_accessed=$REPOSITORIES_ACCESSED" >> $GITHUB_OUTPUT
          echo "repositories_failed=$REPOSITORIES_FAILED" >> $GITHUB_OUTPUT

          # Check if at least one repository was accessible
          if [[ -z "$REPOSITORIES_ACCESSED" ]]; then
            echo "Error: No releases could be fetched from any repository"
            exit 1
          fi

          echo "Repository access summary:"
          echo "Accessible repositories:$REPOSITORIES_ACCESSED"
          echo "Failed repositories:$REPOSITORIES_FAILED"

      - name: Process available releases
        id: process_releases
        run: |
          # Initialize tracking
          FILES_CREATED=()
          FILES_SKIPPED=()
          PROCESSING_ERRORS=()
          TOTAL_PROCESSED=0

          # Helper function to process a single release
          process_single_release() {
            local source_repo="$1"
            local release_tag="$2"
            local release_url="$3"
            local release_date="$4"
            
            echo "Processing release: $release_tag from $source_repo"
            TOTAL_PROCESSED=$((TOTAL_PROCESSED + 1))
            
            # Determine the correct author based on release type
            local author=""
            if [[ "$source_repo" == "ublue-os/bluefin-lts" ]] || [[ "$release_tag" == lts-* ]]; then
              author="bluefin-lts-release-bot"
            elif [[ "$release_tag" == *"gts"* ]]; then
              author="bluefin-gts-release-bot"
            else
              author="bluefin-release-bot"
            fi
            
            echo "Using author: $author for release type"
            
            # Get detailed release data
            RELEASE_DATA=$(curl -s -H "Accept: application/vnd.github.v3+json" \
              -H "Authorization: Bearer ${{ secrets.GITHUB_TOKEN }}" \
              "https://api.github.com/repos/$source_repo/releases/tags/$release_tag")
            
            if [[ -z "$RELEASE_DATA" ]] || echo "$RELEASE_DATA" | jq -e '.message // .errors' > /dev/null 2>&1 || ! echo "$RELEASE_DATA" | jq empty > /dev/null 2>&1; then
              echo "Warning: Could not fetch detailed data for $release_tag from $source_repo"
              PROCESSING_ERRORS+=("$source_repo:$release_tag - API access error")
              return 1
            fi
            
            # Extract detailed release information with error handling
            if ! RELEASE_NAME=$(echo "$RELEASE_DATA" | jq -r '.name // .tag_name' 2>/dev/null) || \
               ! RELEASE_BODY=$(echo "$RELEASE_DATA" | jq -r '.body // ""' 2>/dev/null); then
              echo "Error parsing release data for $release_tag from $source_repo"
              PROCESSING_ERRORS+=("$source_repo:$release_tag - Data parsing error")
              return 1
            fi
            
            # Save release body for processing
            echo "$RELEASE_BODY" > "/tmp/release_body_${source_repo//\//_}_${release_tag}.md"
            
            # Process this release using existing logic from original workflow
            output=$(./scripts/process_single_release.sh "$source_repo" "$release_tag" "$release_url" "$release_date" "$RELEASE_NAME" "$RELEASE_BODY" "false" "$author" 2>&1)
            local result=$?
            
            echo "$output"
            
            if [[ $result -eq 0 ]]; then
                if echo "$output" | grep -q "SKIPPED:"; then
                    FILES_SKIPPED+=("$source_repo:$release_tag")
                    echo "⏭️ Skipped $release_tag (file already exists)"
                else
                    FILES_CREATED+=("$source_repo:$release_tag")
                    echo "✅ Successfully created changelog for $release_tag"
                fi
            else
                PROCESSING_ERRORS+=("$source_repo:$release_tag - Processing error ($result)")
                echo "❌ Error processing $release_tag (exit code: $result)"
            fi
          }

          # Process releases based on trigger type
          if [[ "${{ github.event_name }}" == "workflow_dispatch" ]] || [[ "${{ github.event_name }}" == "schedule" ]]; then
            echo "Processing all available releases from ${{ github.event_name }}..."
            
            # Process bluefin stable release if available
            if [[ "${{ steps.fetch_latest_releases.outputs.bluefin_stable_available }}" == "true" ]]; then
              process_single_release "ublue-os/bluefin" \
                "${{ steps.fetch_latest_releases.outputs.bluefin_stable_tag }}" \
                "${{ steps.fetch_latest_releases.outputs.bluefin_stable_url }}" \
                "${{ steps.fetch_latest_releases.outputs.bluefin_stable_date }}"
            fi
            
            # Process bluefin GTS release if available
            if [[ "${{ steps.fetch_latest_releases.outputs.bluefin_gts_available }}" == "true" ]]; then
              process_single_release "ublue-os/bluefin" \
                "${{ steps.fetch_latest_releases.outputs.bluefin_gts_tag }}" \
                "${{ steps.fetch_latest_releases.outputs.bluefin_gts_url }}" \
                "${{ steps.fetch_latest_releases.outputs.bluefin_gts_date }}"
            fi
            
            # Process bluefin-lts release if available
            if [[ "${{ steps.fetch_latest_releases.outputs.bluefin_lts_available }}" == "true" ]]; then
              process_single_release "ublue-os/bluefin-lts" \
                "${{ steps.fetch_latest_releases.outputs.bluefin_lts_tag }}" \
                "${{ steps.fetch_latest_releases.outputs.bluefin_lts_url }}" \
                "${{ steps.fetch_latest_releases.outputs.bluefin_lts_date }}"
            fi
          else
            echo "Processing single release from repository dispatch..."
            
            # Handle repository_dispatch (single release)
            RELEASE_TAG="${{ github.event.client_payload.tag_name }}"
            RELEASE_URL="${{ github.event.client_payload.html_url }}"
            
            # Determine source repo from URL or tag pattern
            if [[ "$RELEASE_URL" == *"bluefin-lts"* ]] || [[ "$RELEASE_TAG" == lts-* ]]; then
              SOURCE_REPO="ublue-os/bluefin-lts"
            else
              SOURCE_REPO="ublue-os/bluefin"
            fi
            
            # For repository_dispatch, we need to get the release date
            RELEASE_DATA=$(curl -s -H "Accept: application/vnd.github.v3+json" \
              -H "Authorization: Bearer ${{ secrets.GITHUB_TOKEN }}" \
              "https://api.github.com/repos/$SOURCE_REPO/releases/tags/$RELEASE_TAG")
            
            if [[ -z "$RELEASE_DATA" ]] || echo "$RELEASE_DATA" | jq -e '.message // .errors' > /dev/null 2>&1 || ! echo "$RELEASE_DATA" | jq empty > /dev/null 2>&1; then
              echo "Error: Release not found for tag $RELEASE_TAG in $SOURCE_REPO"
              PROCESSING_ERRORS+=("$SOURCE_REPO:$RELEASE_TAG - Release not found")
            else
              if RELEASE_DATE=$(echo "$RELEASE_DATA" | jq -r '.published_at' 2>/dev/null) && \
                 RELEASE_NAME=$(echo "$RELEASE_DATA" | jq -r '.name // .tag_name' 2>/dev/null) && \
                 RELEASE_BODY=$(echo "$RELEASE_DATA" | jq -r '.body // ""' 2>/dev/null) && \
                 [[ "$RELEASE_DATE" != "null" && "$RELEASE_NAME" != "null" ]]; then
              
              # Determine the correct author based on release type
              AUTHOR=""
              if [[ "$SOURCE_REPO" == "ublue-os/bluefin-lts" ]] || [[ "$RELEASE_TAG" == lts-* ]]; then
                AUTHOR="bluefin-lts-release-bot"
              elif [[ "$RELEASE_TAG" == *"gts"* ]]; then
                AUTHOR="bluefin-gts-release-bot"
              else
                AUTHOR="bluefin-release-bot"
              fi
              
                echo "Using author: $AUTHOR for repository dispatch release"
                
                # Call process_single_release with author parameter
                output=$(./scripts/process_single_release.sh "$SOURCE_REPO" "$RELEASE_TAG" "$RELEASE_URL" "$RELEASE_DATE" "$RELEASE_NAME" "$RELEASE_BODY" "false" "$AUTHOR" 2>&1)
                local result=$?
                
                echo "$output"
                
                if [[ $result -eq 0 ]]; then
                    if echo "$output" | grep -q "SKIPPED:"; then
                        FILES_SKIPPED+=("$SOURCE_REPO:$RELEASE_TAG")
                        echo "⏭️ Skipped $RELEASE_TAG (file already exists)"
                    else
                        FILES_CREATED+=("$SOURCE_REPO:$RELEASE_TAG")
                        echo "✅ Successfully created changelog for $RELEASE_TAG"
                    fi
                else
                    PROCESSING_ERRORS+=("$SOURCE_REPO:$RELEASE_TAG - Processing error ($result)")
                    echo "❌ Error processing $RELEASE_TAG (exit code: $result)"
                fi
              else
                echo "Error parsing repository dispatch release data"
                PROCESSING_ERRORS+=("$SOURCE_REPO:$RELEASE_TAG - Data parsing error")
              fi
            fi
          fi

          # Output results for next steps
          echo "files_created_count=${#FILES_CREATED[@]}" >> $GITHUB_OUTPUT
          echo "files_skipped_count=${#FILES_SKIPPED[@]}" >> $GITHUB_OUTPUT
          echo "processing_errors_count=${#PROCESSING_ERRORS[@]}" >> $GITHUB_OUTPUT
          echo "total_processed=$TOTAL_PROCESSED" >> $GITHUB_OUTPUT

          # Save detailed results for PR description and summary
          printf '%s\n' "${FILES_CREATED[@]}" > /tmp/files_created.txt
          printf '%s\n' "${FILES_SKIPPED[@]}" > /tmp/files_skipped.txt
          printf '%s\n' "${PROCESSING_ERRORS[@]}" > /tmp/processing_errors.txt

          echo "Processing complete:"
          echo "- Total processed: $TOTAL_PROCESSED"
          echo "- Files created: ${#FILES_CREATED[@]}"
          echo "- Files skipped: ${#FILES_SKIPPED[@]}"
          echo "- Processing errors: ${#PROCESSING_ERRORS[@]}"

      - name: Create branch and commit changes
        if: steps.process_releases.outputs.files_created_count != '0'
        id: create_branch
        run: |
          FILES_CREATED_COUNT="${{ steps.process_releases.outputs.files_created_count }}"

          # Create branch name with timestamp
          BRANCH_NAME="automerge/changelog-sync-$(date +%s)"
          echo "branch_name=$BRANCH_NAME" >> $GITHUB_OUTPUT

          git config --local user.email "action@github.com"
          git config --local user.name "GitHub Action"

          # Create and checkout new branch
          git checkout -b "$BRANCH_NAME"

          # Add all changelog files
          git add changelogs/

          # Check if there are actual changes to commit
          if git diff --staged --quiet; then
            echo "No changes to commit"
            echo "has_changes=false" >> $GITHUB_OUTPUT
            exit 0
          fi

          # Create commit message
          COMMIT_MESSAGE="feat(changelogs): auto-sync Bluefin releases"$'\n\n'"Automatically generated $FILES_CREATED_COUNT changelog entries from multiple repositories"

          git commit -m "$COMMIT_MESSAGE"

          # Push the branch
          git push origin "$BRANCH_NAME"
          echo "has_changes=true" >> $GITHUB_OUTPUT

      - name: Create Pull Request with Auto-merge
        if: steps.create_branch.outputs.has_changes == 'true'
        id: create_pr
        run: |
          BRANCH_NAME="${{ steps.create_branch.outputs.branch_name }}"
          FILES_CREATED_COUNT="${{ steps.process_releases.outputs.files_created_count }}"
          FILES_SKIPPED_COUNT="${{ steps.process_releases.outputs.files_skipped_count }}"
          PROCESSING_ERRORS_COUNT="${{ steps.process_releases.outputs.processing_errors_count }}"
          TOTAL_PROCESSED="${{ steps.process_releases.outputs.total_processed }}"

          # Build comprehensive PR description
          PR_TITLE="feat(changelogs): auto-sync Bluefin releases - $FILES_CREATED_COUNT changelog(s) created"

          # Create PR body with sections
          PR_BODY="## 🚀 Auto-Merge Bluefin Release Changelog Sync"
          PR_BODY="$PR_BODY"$'\n\n'"This PR adds changelog entries for Bluefin releases with enhanced auto-merge functionality."
          PR_BODY="$PR_BODY"$'\n\n'"### Summary"
          PR_BODY="$PR_BODY"$'\n'"- **Files Created:** $FILES_CREATED_COUNT"
          PR_BODY="$PR_BODY"$'\n'"- **Files Skipped:** $FILES_SKIPPED_COUNT"
          PR_BODY="$PR_BODY"$'\n'"- **Processing Errors:** $PROCESSING_ERRORS_COUNT"
          PR_BODY="$PR_BODY"$'\n'"- **Total Processed:** $TOTAL_PROCESSED"
          PR_BODY="$PR_BODY"$'\n'"- **Trigger:** ${{ github.event_name }}"
          PR_BODY="$PR_BODY"$'\n'"- **Auto-merge:** ✅ Enabled"

          # Add repository access info for workflow_dispatch
          if [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            REPOS_ACCESSED="${{ steps.fetch_latest_releases.outputs.repositories_accessed }}"
            REPOS_FAILED="${{ steps.fetch_latest_releases.outputs.repositories_failed }}"
            PR_BODY="$PR_BODY"$'\n\n'"### Repository Access Status"
            PR_BODY="$PR_BODY"$'\n'"- **Accessible:** $REPOS_ACCESSED"
            PR_BODY="$PR_BODY"$'\n'"- **Failed:** $REPOS_FAILED"
          fi

          # Add details from files if they exist
          if [[ -f "/tmp/files_created.txt" && -s "/tmp/files_created.txt" ]]; then
            PR_BODY="$PR_BODY"$'\n\n'"### Files Created"
            while read -r line; do
              if [[ -n "$line" ]]; then
                PR_BODY="$PR_BODY"$'\n'"- ✅ $line"
              fi
            done < /tmp/files_created.txt
          fi

          if [[ -f "/tmp/files_skipped.txt" && -s "/tmp/files_skipped.txt" ]]; then
            PR_BODY="$PR_BODY"$'\n\n'"### Files Skipped"
            while read -r line; do
              if [[ -n "$line" ]]; then
                PR_BODY="$PR_BODY"$'\n'"- ⏭️ $line"
              fi
            done < /tmp/files_skipped.txt
          fi

          if [[ -f "/tmp/processing_errors.txt" && -s "/tmp/processing_errors.txt" ]]; then
            PR_BODY="$PR_BODY"$'\n\n'"### Processing Errors"
            while read -r line; do
              if [[ -n "$line" ]]; then
                PR_BODY="$PR_BODY"$'\n'"- ❌ $line"
              fi
            done < /tmp/processing_errors.txt
          fi

          PR_BODY="$PR_BODY"$'\n\n'"### Auto-Merge Information"
          PR_BODY="$PR_BODY"$'\n'"- This PR will automatically merge once all status checks pass"
          PR_BODY="$PR_BODY"$'\n'"- Reviewers can still examine the changes during the status check period"
          PR_BODY="$PR_BODY"$'\n'"- Auto-merge can be disabled manually if needed"
          PR_BODY="$PR_BODY"$'\n\n'"**Version Types:**"
          PR_BODY="$PR_BODY"$'\n'"- 🚢 **Stable**: Regular production releases from ublue-os/bluefin"
          PR_BODY="$PR_BODY"$'\n'"- ⭐ **GTS**: Grand Touring Support releases (extended testing)"
          PR_BODY="$PR_BODY"$'\n'"- 🔒 **LTS**: Long Term Support releases from ublue-os/bluefin-lts"

          # Create pull request using GitHub API and capture response
          PR_RESPONSE=$(curl -s -X POST \
            -H "Accept: application/vnd.github+json" \
            -H "Authorization: Bearer ${{ secrets.GITHUB_TOKEN }}" \
            -H "X-GitHub-Api-Version: 2022-11-28" \
            -H "Content-Type: application/json" \
            "https://api.github.com/repos/${{ github.repository }}/pulls" \
            -d "{
              \"title\": $(echo "$PR_TITLE" | jq -Rs .),
              \"head\": \"$BRANCH_NAME\",
              \"base\": \"main\",
              \"body\": $(echo "$PR_BODY" | jq -Rs .),
              \"draft\": false
            }")

          # Check if PR creation was successful and extract PR number
          if echo "$PR_RESPONSE" | jq -e '.number' > /dev/null; then
            PR_NUMBER=$(echo "$PR_RESPONSE" | jq -r '.number')
            echo "pr_number=$PR_NUMBER" >> $GITHUB_OUTPUT
            echo "pr_created=true" >> $GITHUB_OUTPUT
            echo "✅ Pull request #$PR_NUMBER created successfully"
          else
            echo "❌ Failed to create pull request"
            echo "API Response: $PR_RESPONSE"
            echo "pr_created=false" >> $GITHUB_OUTPUT
            exit 1
          fi

      - name: Enable Auto-merge
        if: steps.create_pr.outputs.pr_created == 'true'
        run: |
          PR_NUMBER="${{ steps.create_pr.outputs.pr_number }}"

          echo "🔄 Enabling auto-merge for PR #$PR_NUMBER..."

          # Enable auto-merge using GraphQL API (the correct way)
          ENABLE_AUTOMERGE_QUERY='
          mutation($pullRequestId: ID!) {
            enablePullRequestAutoMerge(input: {
              pullRequestId: $pullRequestId,
              mergeMethod: MERGE
            }) {
              pullRequest {
                id
                number
                autoMergeRequest {
                  enabledAt
                  enabledBy {
                    login
                  }
                }
              }
            }
          }'

          # First, get the PR node ID using REST API
          PR_DATA=$(curl -s \
            -H "Accept: application/vnd.github+json" \
            -H "Authorization: Bearer ${{ secrets.GITHUB_TOKEN }}" \
            -H "X-GitHub-Api-Version: 2022-11-28" \
            "https://api.github.com/repos/${{ github.repository }}/pulls/$PR_NUMBER")

          if PR_NODE_ID=$(echo "$PR_DATA" | jq -r '.node_id' 2>/dev/null) && [[ "$PR_NODE_ID" != "null" && -n "$PR_NODE_ID" ]]; then
            echo "✅ Got PR node ID: $PR_NODE_ID"
            
            # Enable auto-merge using GraphQL API
            AUTOMERGE_RESPONSE=$(curl -s -X POST \
              -H "Accept: application/vnd.github+json" \
              -H "Authorization: Bearer ${{ secrets.GITHUB_TOKEN }}" \
              -H "Content-Type: application/json" \
              "https://api.github.com/graphql" \
              -d "{
                \"query\": $(echo "$ENABLE_AUTOMERGE_QUERY" | jq -Rs .),
                \"variables\": {
                  \"pullRequestId\": \"$PR_NODE_ID\"
                }
              }")
            
            echo "Auto-merge response: $AUTOMERGE_RESPONSE"
            
            # Check if auto-merge was enabled successfully
            if echo "$AUTOMERGE_RESPONSE" | jq -e '.data.enablePullRequestAutoMerge.pullRequest.autoMergeRequest' > /dev/null 2>&1; then
              ENABLED_AT=$(echo "$AUTOMERGE_RESPONSE" | jq -r '.data.enablePullRequestAutoMerge.pullRequest.autoMergeRequest.enabledAt')
              ENABLED_BY=$(echo "$AUTOMERGE_RESPONSE" | jq -r '.data.enablePullRequestAutoMerge.pullRequest.autoMergeRequest.enabledBy.login')
              echo "✅ Auto-merge enabled successfully for PR #$PR_NUMBER"
              echo "   Enabled at: $ENABLED_AT"
              echo "   Enabled by: $ENABLED_BY"
              echo "   The PR will automatically merge when all required status checks pass."
            elif echo "$AUTOMERGE_RESPONSE" | jq -e '.errors' > /dev/null 2>&1; then
              ERRORS=$(echo "$AUTOMERGE_RESPONSE" | jq -r '.errors[].message' | tr '\n' '; ')
              echo "⚠️ Failed to enable auto-merge for PR #$PR_NUMBER"
              echo "   GraphQL errors: $ERRORS"
              echo "   The PR was created successfully but will require manual merging."
            else
              echo "⚠️ Unexpected response when enabling auto-merge for PR #$PR_NUMBER"
              echo "   Response: $AUTOMERGE_RESPONSE"
              echo "   The PR was created successfully but auto-merge status is unclear."
            fi
          else
            echo "❌ Could not get PR node ID for auto-merge"
            echo "   PR Response: $PR_DATA"
            echo "   The PR was created successfully but auto-merge cannot be enabled."
          fi

      - name: Create comprehensive summary
        run: |
          FILES_CREATED_COUNT="${{ steps.process_releases.outputs.files_created_count || '0' }}"
          FILES_SKIPPED_COUNT="${{ steps.process_releases.outputs.files_skipped_count || '0' }}"
          PROCESSING_ERRORS_COUNT="${{ steps.process_releases.outputs.processing_errors_count || '0' }}"
          TOTAL_PROCESSED="${{ steps.process_releases.outputs.total_processed || '0' }}"

          echo "## 🚀 Auto-Merge Bluefin Release Sync Complete" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          # Summary statistics
          echo "### 📊 Processing Summary" >> $GITHUB_STEP_SUMMARY
          echo "- **Total Processed:** $TOTAL_PROCESSED release(s)" >> $GITHUB_STEP_SUMMARY
          echo "- **Files Created:** $FILES_CREATED_COUNT" >> $GITHUB_STEP_SUMMARY
          echo "- **Files Skipped:** $FILES_SKIPPED_COUNT" >> $GITHUB_STEP_SUMMARY
          echo "- **Processing Errors:** $PROCESSING_ERRORS_COUNT" >> $GITHUB_STEP_SUMMARY
          echo "- **Trigger:** ${{ github.event_name }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Auto-merge:** ✅ Enabled" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          # Repository access status (for workflow_dispatch)
          if [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            echo "### 🔗 Repository Access Status" >> $GITHUB_STEP_SUMMARY
            REPOS_ACCESSED="${{ steps.fetch_latest_releases.outputs.repositories_accessed || 'None' }}"
            REPOS_FAILED="${{ steps.fetch_latest_releases.outputs.repositories_failed || 'None' }}"
            
            echo "- **✅ Accessible Repositories:** $REPOS_ACCESSED" >> $GITHUB_STEP_SUMMARY
            echo "- **❌ Failed Repositories:** $REPOS_FAILED" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
          fi

          # Detailed results
          if [[ -f "/tmp/files_created.txt" && -s "/tmp/files_created.txt" ]]; then
            echo "### ✅ Created Changelog Files" >> $GITHUB_STEP_SUMMARY
            while read -r line; do
              if [[ -n "$line" ]]; then
                REPO_TAG="$line"
                REPO="${REPO_TAG%:*}"
                TAG="${REPO_TAG#*:}"
                
                # Determine version type based on repo and tag
                if [[ "$REPO" == "ublue-os/bluefin-lts" ]] || [[ "$TAG" == lts-* ]]; then
                  VERSION_TYPE="🔒 LTS"
                elif [[ "$TAG" == *"gts"* ]]; then
                  VERSION_TYPE="⭐ GTS"
                else
                  VERSION_TYPE="🚢 Stable"
                fi
                
                echo "- $VERSION_TYPE **$TAG** from \`$REPO\`" >> $GITHUB_STEP_SUMMARY
              fi
            done < /tmp/files_created.txt
            echo "" >> $GITHUB_STEP_SUMMARY
          fi

          if [[ -f "/tmp/files_skipped.txt" && -s "/tmp/files_skipped.txt" ]]; then
            echo "### ⏭️ Skipped Files" >> $GITHUB_STEP_SUMMARY
            while read -r line; do
              if [[ -n "$line" ]]; then
                echo "- $line" >> $GITHUB_STEP_SUMMARY
              fi
            done < /tmp/files_skipped.txt
            echo "" >> $GITHUB_STEP_SUMMARY
          fi

          if [[ -f "/tmp/processing_errors.txt" && -s "/tmp/processing_errors.txt" ]]; then
            echo "### ⚠️ Processing Errors" >> $GITHUB_STEP_SUMMARY
            while read -r line; do
              if [[ -n "$line" ]]; then
                echo "- $line" >> $GITHUB_STEP_SUMMARY
              fi
            done < /tmp/processing_errors.txt
            echo "" >> $GITHUB_STEP_SUMMARY
          fi

          # Next steps
          if [[ "${{ steps.create_branch.outputs.has_changes }}" == "true" ]]; then
            echo "### 🔄 Auto-Merge Status" >> $GITHUB_STEP_SUMMARY
            echo "✅ **Pull request created with auto-merge enabled** - $FILES_CREATED_COUNT changelog entries" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "**The PR will automatically merge when:**" >> $GITHUB_STEP_SUMMARY
            echo "- All required status checks pass" >> $GITHUB_STEP_SUMMARY
            echo "- No conflicts exist with the base branch" >> $GITHUB_STEP_SUMMARY
            echo "- Auto-merge is not manually disabled" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "**Reviewers can still:**" >> $GITHUB_STEP_SUMMARY
            echo "- Examine changelog content before auto-merge" >> $GITHUB_STEP_SUMMARY
            echo "- Disable auto-merge if issues are found" >> $GITHUB_STEP_SUMMARY
            echo "- Request changes to pause the auto-merge process" >> $GITHUB_STEP_SUMMARY
          else
            echo "### ℹ️ No Action Required" >> $GITHUB_STEP_SUMMARY
            if [[ "$FILES_CREATED_COUNT" -eq 0 && "$FILES_SKIPPED_COUNT" -gt 0 ]]; then
              echo "All changelog entries already existed - no new files created" >> $GITHUB_STEP_SUMMARY
            elif [[ "$PROCESSING_ERRORS_COUNT" -gt 0 ]]; then
              echo "Processing completed with errors - please check the error details above" >> $GITHUB_STEP_SUMMARY
            else
              echo "No changelog entries were needed at this time" >> $GITHUB_STEP_SUMMARY
            fi
          fi
